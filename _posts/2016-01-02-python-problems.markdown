---
layout: post
title:  "Python, дайте жалобную книгу"
date:   2016-01-02 10:51:21
categories: python
---

Пускай перед нами стоит обычная задача написания алгоритма сортировки при помощи метода выбора,
которая состоит в следующем

1. Определяем текущий индекс равным стартовой позици

2. Если текущий индекс меньше последней позиции, находим минимальное значение в подмассиве,
   начиная с позиции текущего индекса, выполняем операцию обмена, увеличиваем текущий индекс,
   повторяем шаг 2, в противном случае алгоритм заканчивается

#### Чего тут сложного? Где проблема?
А дело вот в чем: "Встроенная функция нахождения минимума функции в данном алгоритме - бесполезна!"
Из этого следует, что нам нужна функция argmin, которой в стандартной библиотеке нет.

Реализовать ее на самом Пайтоне не так уж сложно. Но в данном случае главной проблемой является
продуманость того, как должны выглядеть аргументы. Из опыта С, становится очевидным, что прототи вида
`long int argmin(int a[], long int length);`, является солидным источником ошибок.

{% gist tshev/9a3e0316bf5213178d40 %}

Сначала о хорошем:

* мы можем выполнить алгоритм для любого непрерывного подмассмва
* можем использовать пользовательскую функцию сравнения 

Теперь о плохом:

* вызов функции в пайтоне дорогой, и приводит к проблемам при его использовании в линейном алгоритме
* пришлось написать новую функцию, а не воспользоваться встроенной,
ибо функция `min(iterable[, key=func]) -> value` возращает значение вместо индекса
* реализация argmin на Python работает более медленно, даже при сравнении со встроенной функцией,
но делает то, что нужно

Приведем полную реализацию:
{% gist tshev/109c1fa3f93677f8f7f3 %}

Еще немного грустного:

* при каждой операцие инкремента индекса, создается новое целое число
* мы используем словарь для получения значений именованых аргументов

Сравним с реализацией на C++:

    template<typename It>
    void selection_sort(It f, It l) {
        for(; f != l; f++) {
            auto min = std::min_element(f, l);
            std::iter_swap(f, min);
        }
    }

Напоследок сообщаю результаты измерения производительнсоти на ничтожно маленьком массиве в 5000 элементов
на моем ноутбуке:

* Python справился за 3.5 секунды
* C++ с ключем -O0 справился за 0.231 секунды

Можно было бы построить график, но разница слишком разящая.


[tshev]:      http://tshev.org
[tshev-gh]:   https://github.com/tshev
[jekyll-help]: https://github.com/tshev

