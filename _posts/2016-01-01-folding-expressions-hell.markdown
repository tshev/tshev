---
layout: post
title:  "Первое знакомство с folding expressions или добро пожаловать в мой мир"
date:   2016-01-01 10:51:21
categories: c++
---
## Лирическое отступление

Перед новым годом я зарекся перестать проверять свою почту 
(это занимает тучу времени, ибо gmail грузится не быстро,
да и еще всегда помимо обычных человеческих писем,
приходит большое количество -/+ интересной рассылки да и еще
пачка уведомлений от сервисов, которыми пользуюсь:
Python-anywhere, Amazon EC2, Evernote и прочих).

Поздним утром 1-го января после празднования Нового года меня занесло на просторы WWW в поисках интересного.
 После утраченного часа в твиттере, фейсбуке, и реддите, 
я вспомнил о тех обещаниях, которые дал сам себе, и полез в сеть в поисках чего-то интересного.

Я забрел на страницу о clang-format, узнал о появлении новой опции AlignConsecutiveDeclarations,
потом с горечью узнал, что у моей Федоры 23, на данный момент установлен clang-3.7 и я не могу воспользоваться этой опцией.
В грустных чувствах, я пошел и прочитал затертые до дыр страницы [Auto-Vectorization in LLVM](http://llvm.org/docs/Vectorizers.html),
почитал еще немножко об [AddressSanitizer](http://clang.llvm.org/docs/AddressSanitizer.html), [MemorySanitizer](http://clang.llvm.org/docs/MemorySanitizer.html), [ThreadSanitizer](http://clang.llvm.org/docs/ThreadSanitizer.html).

## Начало
Случилось так, что потом забрел на страницу [C++ imlementation status](http://clang.llvm.org/cxx_status.html) в раздел C++1z implementation status, начал прокликивать ссылки попал [open-std.org](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4295.html), а именно на предложения по поводу использования folding expressions. Авторство которого принадлежит Дрю Саттону и Ричарду Смиту.

```
Andrew Sutton, Richard Smith
Date: 2014-11-07
Document number: N4295
Revises: N4191 
```

Таким образом я созерцал очередную нотацию Бекуса-Наура. На этот раз по поводу сворачивания выражений
 при использовании шаблонов с переменным количеством аргументов.

    fold-expression:
          ( cast-expression fold-operator ... )
          ( ... fold-operator cast-expression )
          ( cast-expression fold-operator ... fold-operator cast-expression )


    fold-operator: one of
        +  -  *  /  %  ^  &  |  ~  =  <  >  <<  >>
        +=  -=  *=  /=  %=  ^=  &=  |=  <<=  >>=
        ==  !=  <=  >=  &&  ||  ,  .*  ->*

Таким образом мы с радостью обнаруживаем, что теория может превратится в практику при использования ключа `-std=c++1z`. Что пора двинуться с места в каръер и написать код и потрогать руками результат.

{% gist tshev/868a065f2dcdb3fe4fa8 %}

Дальше, загляну в таблицу "Value of folding empty sequences", мы можем заметить, что значением по умполчанию является истрина, таким образом, можно упростить функцию `all_true` и записать:

    template <typename... Args>
    bool all_true(Args... args) {
      return (... && args);
    }

Напомню, що для использования данного функционала необходим компилятор clang-3.7, либо более новой версии. Если вы владеете `gcc version 5.3.1`, то вы не можете воспользоваться данным кодом, так как данная часть от C++1z в нем еще не реализована.

Итак. Прежде, чем двинуться дальше и улучшить данное решение
(мне, например, хотелось бы вызывать данный метод для переданного предикатов, а не морочится c ручными вызовами предикатов `all(pred(x1), pred(x2)))`, вернемся в прошлое, а именно к C++14, а возможно и к C++14 и реализуем обозначенную выше идею, при этом воспользуемя ключевым словом constexpr, чтобы возможно было выполнять подобные вычисления на этапе компиляции, а заодно и воспользоваться `static_assert` для создания примитивных тестов, которые будут давать знать о себе в случае ошибки также на этапе компиляции:

{% gist tshev/b585de9caa0e7556defe %}

Вернемся назад к C++1z и желанию реализовать обобщенную версию функции `all_true`.

{% gist tshev/1af3feedffb9d92bd679 %}

Замечания по коду:

* В примере мы имеем дело с гомогенным случаем - аргументы следующие за предикатом, имеют один и тот же тип
* Функция `all` допускает передачу аргументов разных типов
* При передачи аргементов разных типов, будет выполнятся неявное преобразование типов к типу, указанному, в области определения бинарного предиката, за исключением случая использования полиморфных лямбда выражений, а также функциональных объектов, с шаблонным оператором круглых скобок
* Поскольку аргументы передаются по значению, использование функции `all` является допустимым для объектов, которые мают достаточно малый размер. Решение о допустимых размерах объекта оставим читателю, но стоит заметить, что я бы заметил, что на мой взгляд - размер в 1-3 машинных слова вполне допустим, что позволяет вызывать функцию без существенных утрат в производительности,  связанных с копированием.

## Добро пожаловать в мой мир
Давайте сделаем такой финт ушами для решение проблемы с передачей встроенных типов по констатной ссылке, поскольку нам бы хотелось их передавать по значению, а вот пользовательские типы, например вектор, - по констатной ссылке. И это можем сделать при помощи правил перегрузки функций.

Поскольку код, получился большим, пустим в дело заголовочный, файл. В коде мы применим для получения
желаемого эффекта, воспользуемся той же техникой, что используется в STL запуска разных алгоритмов для различных видов итераторов.

{% gist tshev/e559e548c55fc2e78722 %}

И в качестве последнего штриха вернемся в настоящее и заставим данный код работать c C++14 при помощи рекурсии для шаблонов с переменным количеством аргементов.
{% gist tshev/44c5f0338e6b3d16fb0e %}

## Финальные замечания
Стоит заметить, что при работе с функцией all, стоит быть аккуратным с неявными преобразованиями, типов, если вы все же решите проверять предикатом аргументы разных типов

### Пример ужасного использования:
    auto check == all([](int x) { return x % 2 == 0; }, 4, 8, false);

### Пример допустимого использования:
    auto check == all([](auto &x) {
                                // какой-то код
                                 }, T1{}, T2{}, T1{});

### Что в определенной степени эквивалентно записи
    struct Pred {
        bool operator(const T1 &x) {
            // implementation for T1
        }
        bool operator(const T2 &x) {
            // implementation for T2
        }
    };
    auto check = all(Pred{}, T1{}, T2{})

Если вы сталкивались с проблемами при неявных преобразованиях типов,
тогда вы будете использовать реализацию, которая не приведет к сюрпризам.

Ну и напоследок могу сказать, что можно более аккуратно ввести концепции, записав требования не только к предикатам,
но и к аргементам, следующим за ним, и но при этом пришлось бы переопределить понятие Гомогенного(однородного) предиката, тем самым
запретив использовать код, для списка параметров разных типов...

### Как ты назовешь то, что получилось
Краткая запись гетерогенного предиката с возможностью сужения к гомогенному.

Можно еще провести измерения производительнсоти отдельно для случаев с C++14 и C++1z, но это уже совсем другая история.

Детальнее о концепциях можете почитать вот здесь: <http://www.elementsofprogramming.com/eop-concepts.pdf>

[tshev]:      http://tshev.org
[tshev-gh]:   https://github.com/tshev
[jekyll-help]: https://github.com/tshev

